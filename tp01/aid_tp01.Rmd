---
title: "AID TP 01"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

```{r}
library(tidyverse)
```

# load + wrangling 

## clientes

```{r}
clientes <- read_csv("data/DNA_03_NEW.csv.bz2") %>% 
  janitor::clean_names()
```

Investigo columna `base_stat_03`, cambiandola a `factor`. Viendo los niveles, me saco de encima las 
filas que no me interesan, lease, las que no son "ACTIVE BASE" o "REJOINER"

```{r}
clientes %>% mutate(base_stat_03 = factor(base_stat_03)) -> clientes

clientes %>%
  select(-x1) %>% 
  filter(base_stat_03 %in% c("ACTIVE BASE", "REJOINNER")) -> clientes
```

## recargas

```{r}
rec01 <- read_csv("data/RECA_CHAN_01_NEW.csv.bz2")
rec02 <- read_csv("data/RECA_CHAN_02_NEW.csv.bz2")
rec03 <- read_csv("data/RECA_CHAN_03_NEW.csv.bz2")
```

Defino una funcion de limpieza para las bases correspondientes a enero, febrero y marzo.
Limpia los nombres, y genera las columnas nuevas necesarias para el posterior analisis.

```{r}
limpio_recargas <- function(x) {
  x %>% janitor::clean_names() %>% 
  select(-x1) %>% 
  filter(purchaseamount > 0) %>% 
  mutate(purchasetime = lubridate::parse_date_time(purchasetime, "d b Y H M S"),
         month = lubridate::month(purchasetime, label = TRUE),
         channel_type = if_else(
           str_detect(channelidentifier, "EMG"),
           true = "tecno", false = "manual"
           )
         ) 
}
```

Aplico la funcion de limpieza y uno los dataframes de recargas en uno solo.

```{r}
list(rec01, rec02, rec03) %>% 
  map(limpio_recargas) %>% 
  reduce(bind_rows) -> recargas
```

## joining

Uno las tablas `recarga` y `clientes`, mediante un inner join, ya que no me interesan
los clientes para los cuales no tengo informacion de recargas, ni las recargas de clientes
que no tengan  `base_stat_03` == REJOINNER o ACTIVE BASE.

```{r}
db <- clientes %>% 
  inner_join(recargas, by = c("accs_mthd_cd" = "customerid"))
```

## limpieza

Elimino tablas simples para ahorrar memoria.

```{r}
rm(list = c(ls(pattern = "rec\\d"), "clientes", "recargas"))
```

# Clientes_Mar21

Calculo valores totales en tabla `db_total` y unicamente las tecnologicas en `db_tecno`.
Luego las uno (mediante un `left_join`, preservando a todos los clientes, independientemente
del tipo de recarga.) y reemplazo los NA (que aparecen en caso de no haber realizado cargas
por medios tecnologicos) por ceros. Almaceno todo en `db_1`.

```{r}

db_total <-
  db %>%
  group_by(accs_mthd_cd) %>%
  summarise(
    monto_total = sum(purchaseamount),
    cant_recargas = n()
  )

db_tecno <-
  db %>%
  filter(channel_type == "tecno") %>%
  group_by(accs_mthd_cd) %>%
  summarise(
    monto_tecno = sum(purchaseamount),
    cant_rtec = n()
  )

db_1 <-
  db_total %>%
  left_join(db_tecno, by = "accs_mthd_cd") %>%
  # cantidad de regargas seguro es int, monto_tecno no necesariamente.
  replace_na(list(monto_tecno = 0, cant_rtec = 0L))

```

Luego, calculo las variables que requieren del los totales y marginales.

```{r}

Clientes_Mar21 <-
  db_1 %>%
  mutate(
    por_tecno_m = monto_tecno / monto_total * 100,
    por_tecno = cant_rtec / cant_recargas * 100,
    cl_tecno = case_when(
      por_tecno >= 70 ~ "1-Tecno",
      por_tecno >= 40 & por_tecno < 70 ~ "2-Mix4070",
      por_tecno > 0 & por_tecno < 40 ~ "3-MixH40",
      por_tecno == 0 ~ "4-No Tecno",
      TRUE ~ "ERROR"
    ),
    cl_tecno = case_when(
      cant_recargas >= 3 ~ cl_tecno,
      cant_recargas < 3 ~ "99-NOSEGM",
      TRUE ~ "ERROR"
    )
  )
```

# db 2

Calculo los resumenes pedidos.

```{r}

Segmentacion_Mar21 <-
  Clientes_Mar21 %>%
  group_by(cl_tecno) %>%
  summarise(
    monto_total_promedio = mean(monto_total),
    monto_tecno_promedio = mean(monto_tecno),
    cant_recargas_promedio = mean(cant_recargas),
    cant_rec_tecno_promedio = mean(cant_rtec)
  )
```


# descriptiva y graficos

La variable `accs_mthd_cd` no es "numerica" hablando estrictamente, por lo que la transformo
en factor para que `skim` no calcule estadisticos que no tienen sentido.

```{r}
skimr::skim(Clientes_Mar21 %>% mutate(accs_mthd_cd = factor(accs_mthd_cd)))
```

Primero grafico unos histogramas, para ver las distribuicones de regargas y montos
en cada nivel de clasificacion.

```{r}
Clientes_Mar21 %>%
  ggplot(aes(cant_recargas)) + geom_histogram(binwidth = 3) + facet_grid(cl_tecno~. , scales = "free")
```

Las distribuciones de cantidad de recargas en varios casos tienen pinta bimodal. 
Una hipotesis es que la gente hace pocas recargas de montos altos, o muchas recargas de montos chicos. 

Al graficar los montos, tambien vemos cierta bimodalidad, lo cual soporta la hipotesis.
Para estudiarlo con mas detalle podria clasificar en dos, separando a *grosso modo* 
las dos modas de una de las variables, y graficar la distribucion de la otra. O mas facil,
graficar la conjunta directamente, mediante un scatterplot.

```{r}
Clientes_Mar21 %>%
  ggplot(aes(monto_total)) + geom_histogram(binwidth = 10) + facet_grid(cl_tecno~. , scales = "free")
```

```{r}
Clientes_Mar21 %>%
  ggplot(aes(monto_total)) + geom_density() + facet_grid(cl_tecno~. , scales = "free")
```

Luego, grafico un scatterplot, que debido al numero de observaciones tarda mucho,
y esta lleno de overplotting, por mas `alpha` o mas chiquito el tamaÃ±o del punto use.
(probe tambien hacer un subsampleo estratificado, manteniendo las proporciones de
los grupos, pero tendria que hacerlo con mas detalle. Dejo el codigo en un anexo al final
para referencia futura.)

```{r}
Clientes_Mar21 %>%
  ggplot(aes(cant_recargas, monto_total, color = cl_tecno)) +
  geom_point(alpha = 0.01, size = 0.1) +
  facet_grid(~cl_tecno, scale = "free") +
  theme(aspect.ratio = 1, legend.position = "none")
```

Una forma de "limpiar" los scatterplots es usando `geom_hex`, que basicamente grafica
la frecuencia de regiones hexagonales, mappeando el numero de observaciones dentro 
de la region al color.

Ademas, como el rango de observaciones es muy amplio (hay zonas muy concentradas
en observaciones y otras practicamente vacias), transformo logaritmicamente las 
frecuencias para asi poder observar un gradiente en las frecuencias.

En otras palabras, esto basicamente grafica la distribucion conjunta de los datos
con respecto a estas variables.

```{r}
Clientes_Mar21 %>%
  ggplot(aes(cant_recargas, monto_total)) +
  geom_hex() + scale_fill_viridis_c(trans = "log") +
  facet_grid(~cl_tecno ) +
  theme(aspect.ratio = 1)
```

# anexo

## stratified subsampling

```{r eval = F}
clientes_subset <-
  Clientes_Mar21 %>%
  group_by(cl_tecno) %>%
  mutate(n_rows = n()) %>%
  sample_frac(0.3, weight = n_rows) %>%
  select(-n_rows) %>% ungroup()
```

