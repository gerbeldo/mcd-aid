---
title: "AID TP01"
author: "German Beldorati Stark"
output:
  html_document:
    df_print: paged
    highlight: kate
    theme:
      version: 4
      code_font: 
        google: JetBrains Mono
editor_options:
  chunk_output_type: console
  markdown:
    wrap: 72
---

```{r}
library(tidyverse)
theme_set(theme_classic())
```

# load + wrangling

## clientes

```{r cache = T, warning=F}
clientes <- read_csv("data/DNA_03_NEW.csv.bz2") %>% 
  janitor::clean_names()
```

Investigo columna `base_stat_03`, cambiandola a `factor`. Viendo los
niveles, me saco de encima las filas que no me interesan, lease, las que
no son "ACTIVE BASE" o "REJOINER"

```{r cache = T}
clientes %>% mutate(base_stat_03 = factor(base_stat_03)) -> clientes

clientes %>%
  select(-x1) %>% 
  filter(base_stat_03 %in% c("ACTIVE BASE", "REJOINNER")) -> clientes
```

## recargas

```{r cache = T, warning = F}
rec01 <- read_csv("data/RECA_CHAN_01_NEW.csv.bz2")
rec02 <- read_csv("data/RECA_CHAN_02_NEW.csv.bz2")
rec03 <- read_csv("data/RECA_CHAN_03_NEW.csv.bz2")
```

Defino una funcion de limpieza para las bases correspondientes a enero,
febrero y marzo. Limpia los nombres, y genera las columnas nuevas
necesarias para el posterior analisis.

```{r}
limpio_recargas <- function(x) {
  x %>% janitor::clean_names() %>% 
  select(-x1) %>% 
  filter(purchaseamount > 0) %>% 
  mutate(purchasetime = lubridate::parse_date_time(purchasetime, "d b Y H M S"),
         month = lubridate::month(purchasetime, label = TRUE),
         channel_type = if_else(
           str_detect(channelidentifier, "EMG"),
           true = "tecno", false = "manual"
           )
         ) 
}
```

Aplico la funcion de limpieza y uno los dataframes de recargas en uno
solo.

```{r cache = T}
list(rec01, rec02, rec03) %>% 
  map(limpio_recargas) %>% 
  reduce(bind_rows) -> recargas
```

## joining

Uno las tablas `recarga` y `clientes`, mediante un inner join, ya que no
me interesan los clientes para los cuales no tengo informacion de
recargas, ni las recargas de clientes que no tengan `base_stat_03` ==
REJOINNER o ACTIVE BASE.

```{r}
db <- clientes %>% 
  inner_join(recargas, by = c("accs_mthd_cd" = "customerid"))
```

## limpieza

Elimino tablas simples para ahorrar memoria.

```{r}
rm(list = c(ls(pattern = "rec\\d"), "recargas"))
```

# Clientes_Mar21

Calculo valores totales en tabla `db_total` y unicamente las
tecnologicas en `db_tecno`. Luego las uno (mediante un `left_join`,
preservando a todos los clientes, independientemente del tipo de
recarga.) y reemplazo los NA (que aparecen en caso de no haber realizado
cargas por medios tecnologicos) por ceros. Almaceno todo en `db_joined`.

```{r cache = T}

db_total <-
  db %>%
  group_by(accs_mthd_cd) %>%
  summarise(
    monto_total = sum(purchaseamount),
    cant_recargas = n()
  )

db_tecno <-
  db %>%
  filter(channel_type == "tecno") %>%
  group_by(accs_mthd_cd) %>%
  summarise(
    monto_tecno = sum(purchaseamount),
    cant_rtec = n()
  )

db_joined <-
  db_total %>%
  left_join(db_tecno, by = "accs_mthd_cd") %>%
  # cantidad de regargas seguro es int, monto_tecno no necesariamente.
  replace_na(list(monto_tecno = 0, cant_rtec = 0L))

```

Luego, calculo las variables que requieren del los totales y marginales.

```{r}

Clientes_Mar21 <-
  db_joined %>%
  mutate(
    por_tecno_m = monto_tecno / monto_total * 100,
    por_tecno = cant_rtec / cant_recargas * 100,
    cl_tecno = case_when(
      por_tecno >= 70 ~ "1-Tecno",
      por_tecno >= 40 & por_tecno < 70 ~ "2-Mix4070",
      por_tecno > 0 & por_tecno < 40 ~ "3-MixH40",
      por_tecno == 0 ~ "4-No Tecno",
      TRUE ~ "ERROR"
    ),
    cl_tecno = case_when(
      cant_recargas >= 3 ~ cl_tecno,
      cant_recargas < 3 ~ "99-NOSEGM",
      TRUE ~ "ERROR"
    )
  )
```

Finalmente agrego la columna `base_stat_03`, que se perdio en un `summarise`.

```{r}
Clientes_Mar21 <- 
  Clientes_Mar21 %>%
    inner_join(clientes, by = "accs_mthd_cd")

rm(clientes)

```


# Segmentacion_Mar21

Calculo los resumenes pedidos.

```{r}

Segmentacion_Mar21 <-
  Clientes_Mar21 %>%
  group_by(cl_tecno) %>%
  summarise(
    monto_total_promedio = mean(monto_total),
    monto_tecno_promedio = mean(monto_tecno),
    cant_recargas_promedio = mean(cant_recargas),
    cant_rec_tecno_promedio = mean(cant_rtec)
  )
```

# descriptiva

La variable `accs_mthd_cd` no es "numerica" hablando estrictamente, por
lo que la transformo en factor para que `skim` no calcule estadisticos
que no tienen sentido.

```{r}
skimr::skim(Clientes_Mar21 %>% mutate(accs_mthd_cd = factor(accs_mthd_cd)))
```

# graficos

## segmentacion

Primero grafico unos histogramas, para ver las distribuicones de
regargas y montos en cada nivel de clasificacion. En todos los casos, se observa
la presencia de outliers. En los histogramas en particular se nota por la escala
del grafico, lo cual indica la presencia de valores extremos, pero luego se ve mejor
en los graficos de dispersion.

```{r}
Clientes_Mar21 %>%
  ggplot(aes(cant_recargas)) +
  geom_histogram(binwidth = 1) +
  facet_grid(cl_tecno ~ ., scales = "free")
```

Las distribuciones de cantidad de recargas en varios casos tienen pinta
bimodal. Una hipotesis es que la gente hace pocas recargas de montos
altos, o muchas recargas de montos chicos.

Filtrando la cantidad de recargas a menos de 75 perdemos unicamente 80 datos, y 
se ve mejor la pinta de las distribuciones.

```{r}
Clientes_Mar21 %>%
  ggplot(aes(cant_recargas)) +
  geom_histogram(binwidth = 1) +
  facet_grid(cl_tecno ~ ., scales = "free") +
  xlim(c(0, 75))
```

Al graficar los montos, tambien vemos cierta bimodalidad, lo cual
soporta la hipotesis. Para estudiarlo con mas detalle podria clasificar
en dos, separando a *grosso modo* las dos modas de una de las variables,
y graficar la distribucion de la otra. O mas facil, graficar la conjunta
directamente, mediante un scatterplot.


```{r}

# en este caso, filtrando el monto total a menores de 300 perdemos ~250 datos unicamente.
Clientes_Mar21 %>%
  ggplot(aes(monto_total)) +
  geom_histogram(binwidth = 5) +
  facet_grid(cl_tecno ~ ., scales = "free") +
  xlim(c(0, 300))
```

Puedo visualizar con un grafico de densidades tambien, ya que monto_total es una 
variable en principio continua, y tenemos bastantes observaciones.

```{r}
Clientes_Mar21 %>%
  ggplot(aes(monto_total)) +
  geom_density() +
  facet_grid(cl_tecno ~ ., scales = "free") +
  xlim(c(0, 300))
```

Luego, grafico un scatterplot, que debido al numero de observaciones
tarda mucho, y esta lleno de overplotting, por mas `alpha` o mas
chiquito el tamaÃ±o del punto use. (probe tambien hacer un subsampleo
estratificado, manteniendo las proporciones de los grupos, pero tendria
que hacerlo con mas detalle. Dejo el codigo en un anexo al final para
referencia futura.)

```{r cache = T}
Clientes_Mar21 %>%
  ggplot(aes(cant_recargas, monto_total, color = cl_tecno)) +
  geom_point(alpha = 0.1, size = 0.31) +
  facet_wrap(~cl_tecno, scale = "free") +
  theme(aspect.ratio = 1, legend.position = "none")
```

Una forma de "limpiar" los scatterplots es usando `geom_hex`, que
basicamente grafica la frecuencia de regiones hexagonales, mappeando el
numero de observaciones dentro de la region al color.

Ademas, como el rango de observaciones es muy amplio (hay zonas muy
concentradas en observaciones y otras practicamente vacias), transformo
logaritmicamente las frecuencias para asi poder observar un gradiente en
las frecuencias.

En otras palabras, esto basicamente grafica la distribucion conjunta de
los datos con respecto a estas variables.

```{r}
Clientes_Mar21 %>%
  ggplot(aes(cant_recargas, monto_total)) +
  geom_hex() +
  scale_fill_viridis_c(trans = "log") +
  facet_wrap(~cl_tecno) +
  theme(aspect.ratio = 1)
  
```

Lo que podemos ver es que en el segmento 1 hay una mayor cantidad de datos en la
region correspondiente a poca cantidad de recargas y montos altos, mientras que 
en el 4 no, la nube tiende esta mas desplazada hacia abajo (montos menores).

## tipo de cliente

Luego, explorando la clasificacion por `base_stat_03`, vemos que son muy pocos
los clientes "REJOINNER". Y ademas, no son la subpoblacion que nos genera la bimodalidad.

```{r}
Clientes_Mar21 %>% 
  #filter(base_stat_03 == "REJOINNER") %>% 
  ggplot(aes(monto_total, fill = base_stat_03)) +
  geom_histogram(binwidth = 5) +
  facet_grid(base_stat_03~., scale = "free") +
  xlim(c(0, 300))
```

El grafico de densidades es ruidoso, probablemente porque monto total no es
estrictamente continuo en este dataset. Mas aun, tiene `r length(unique(Clientes_Mar21$monto_total))` valores posibles.

```{r}
Clientes_Mar21 %>% 
  #filter(base_stat_03 == "REJOINNER") %>% 
  ggplot(aes(monto_total, fill = base_stat_03)) +
  geom_density() +
  facet_grid(base_stat_03~., scale = "free") +
  xlim(c(0, 300))
```


# anexo
## stratified subsampling

```{r eval = F}
clientes_subset <-
  Clientes_Mar21 %>%
  group_by(cl_tecno) %>%
  mutate(n_rows = n()) %>%
  sample_frac(0.3, weight = n_rows) %>%
  select(-n_rows) %>%
  ungroup()
```

## exportar tablas 

Cambio capitalizacion de los nombres de variables y ordeno por id de cliente, para
igualar a lo pedido en el TP. Exporto las tablas a csv.

```{r eval = F}

names(Clientes_Mar21) <- str_to_upper(names(Clientes_Mar21))

Clientes_Mar21 %>%
  relocate(BASE_STAT_03, .after = ACCS_MTHD_CD) %>%
  arrange(ACCS_MTHD_CD) %>% 
  write_csv("tabla1_clientes.csv")

Segmentacion_Mar21 %>% write_csv("tabla2_segmentacion.csv")

```

